diff --git a/crates/seal-cli/src/main.rs b/crates/seal-cli/src/main.rs
index 1234567..abcdefg 100644
--- a/crates/seal-cli/src/main.rs
+++ b/crates/seal-cli/src/main.rs
@@ -1,6 +1,7 @@
 use clap::{Parser, Subcommand};
 use seal::*;
 use std::io::{self, Write};
+use std::fs;
+use std::path::PathBuf;

 #[derive(Parser)]
 #[command(name = "seal-cli")]
@@ -50,8 +51,12 @@ enum Commands {
     },
     /// Decrypt a message using threshold decryption
     Decrypt {
-        #[arg(value_parser = parse_serializable::<EncryptedObject, DefaultEncoding>)]
-        encrypted_object: EncryptedObject,
+        /// Encrypted object as hex string (mutually exclusive with --encrypted-object-file)
+        #[arg(value_parser = parse_serializable::<EncryptedObject, DefaultEncoding>, conflicts_with = "encrypted_object_file")]
+        encrypted_object: Option<EncryptedObject>,
+
+        /// Path to file containing encrypted object as hex string
+        #[arg(long, value_parser = parse_encrypted_object_from_file)]
+        encrypted_object_file: Option<EncryptedObject>,

         #[arg(value_parser = parse_serializable::<SecretKey, DefaultEncoding>)]
         secret_keys: Vec<SecretKey>,
@@ -74,6 +79,20 @@ fn parse_serializable<T: serde::de::DeserializeOwned, E: Encoding>(
     E::decode(s).map_err(|e| e.to_string())
 }

+fn parse_encrypted_object_from_file(path: &str) -> Result<EncryptedObject, String> {
+    // Read the hex string from file
+    let hex_content = fs::read_to_string(path)
+        .map_err(|e| format!("Failed to read file {}: {}", path, e))?;
+
+    // Trim whitespace and newlines
+    let hex_clean = hex_content.trim();
+
+    // Parse as encrypted object using default encoding
+    DefaultEncoding::decode(hex_clean)
+        .map_err(|e| format!("Failed to parse encrypted object from file {}: {}", path, e))
+}
+
 fn main() -> Result<(), Box<dyn std::error::Error>> {
     let cli = Cli::parse();

@@ -115,7 +134,13 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {
         }

         Commands::Decrypt {
-            encrypted_object,
+            encrypted_object: encrypted_object_arg,
+            encrypted_object_file,
             secret_keys,
             key_server_ids,
         } => {
+            // Use encrypted_object from file if provided, otherwise from command line
+            let encrypted_object = encrypted_object_file
+                .or(encrypted_object_arg)
+                .ok_or("Either encrypted_object or --encrypted-object-file must be provided")?;
+
             let key_server_ids = if key_server_ids.is_empty() {
                 None
             } else {
